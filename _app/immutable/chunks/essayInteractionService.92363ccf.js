import{supabase as n}from"./supabase.977684e5.js";import{w as b}from"./index.5fb28099.js";import{m as y}from"./scheduler.77de885a.js";const w={ESSAY:"essay"},u=b({likes:{},shares:{},views:{}}),k="device_id";function x(){try{if(typeof crypto<"u"&&typeof crypto.randomUUID=="function")return crypto.randomUUID();const e=typeof crypto<"u"&&typeof crypto.getRandomValues=="function";return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){let o;if(e){const t=new Uint8Array(1);crypto.getRandomValues(t),o=t[0]%16}else o=Math.random()*16|0;return(r==="x"?o:o&3|8).toString(16)})}catch(e){console.error("Error generating UUID:",e);const r=new Date().getTime(),o=Math.floor(Math.random()*1e7);return`fallback-${r}-${o}`}}function C(){try{const e="__test__";localStorage.setItem(e,e);const r=localStorage.getItem(e)===e;return localStorage.removeItem(e),r}catch{return!1}}async function m(){try{if(!C())return console.warn("localStorage is not available, using temporary device ID"),"temp-"+x();let e=localStorage.getItem(k);return e?console.log("Retrieved existing device ID:",e):(e=x(),localStorage.setItem(k,e),console.log("Created new device ID:",e)),e}catch(e){return console.error("Error in getOrCreateDeviceId:",e),"temp-"+Math.random().toString(36).substring(2,15)}}async function P(){if(console.log("Initializing interaction service"),console.log("Supabase client available:",!!n),!n)return console.error("Supabase client is not initialized"),null;try{try{const{data:r,error:o}=await n.from("essays").select("id").limit(1);o?console.error("Supabase connection test failed:",o):console.log("Supabase connection test successful:",r)}catch(r){console.error("Error testing Supabase connection:",r)}const e=await m();console.log("Device ID created/retrieved:",e),console.log("Current interaction state before refresh:",y(u));try{await v(e),console.log("Successfully refreshed interaction state")}catch(r){console.error("Error refreshing interaction state:",r)}return console.log("Interaction state after refresh:",y(u)),console.log("Interaction service initialized with device ID:",e),e}catch(e){return console.error("Failed to initialize interaction service:",e),null}}async function v(e){try{const{data:r,error:o}=await n.from("essay_interactions").select("essay_id, has_liked, share_count, has_viewed").eq("device_id",e);if(o)throw o;const a={likes:{},shares:{},views:{}};r&&r.forEach(t=>{const i=`${w.ESSAY}:${t.essay_id}`;a.likes[i]=t.has_liked||!1,a.shares[i]=t.share_count||0,a.views[i]=t.has_viewed||!1}),u.set(a)}catch(r){console.error("Failed to refresh interaction state:",r)}}function U(e){return u.subscribe(e)}function M(e){if(!e)return console.error("isLiked called without an essayId"),!1;const r=y(u),o=`${w.ESSAY}:${e}`,a=!!r.likes[o];return console.log(`Checking if essay ${e} is liked: ${a}`),a}const g=new Map;async function A(e){if(g.has(e))return console.log(`Ignoring duplicate like request for essay ${e}`),g.get(e)||Promise.resolve(!1);const r=await m(),o=`${w.ESSAY}:${e}`,t=!!y(u).likes[o],i=(async()=>{u.update(s=>({...s,likes:{...s.likes,[o]:!t}}));try{const{data:s,error:c}=await n.from("essay_interactions").select("id, has_liked").eq("device_id",r).eq("essay_id",e).single();if(c&&c.code!=="PGRST116")throw c;const l=!t;if(s){const{error:f}=await n.from("essay_interactions").update({has_liked:l,updated_at:new Date().toISOString()}).eq("id",s.id);if(f)throw f}else{const{error:f}=await n.from("essay_interactions").insert({device_id:r,essay_id:e,has_liked:l,share_count:0,has_viewed:!0});if(f)throw f}const h=l?1:-1,{error:d}=await n.rpc("increment_essay_like_count",{essay_id:e,increment_by:h});if(d){console.warn("RPC failed, using fallback method for updating like count:",d);const{data:f,error:E}=await n.from("essays").select("like_count").eq("id",e).single();if(E)throw E;const q=Math.max(0,(f.like_count||0)+h),{error:S}=await n.from("essays").update({like_count:q}).eq("id",e);if(S)throw S}return await v(r),l}catch(s){return console.error("Error toggling like:",s),u.update(c=>({...c,likes:{...c.likes,[o]:t}})),t}finally{g.delete(e)}})();return g.set(e,i),i}const _=new Map;async function T(e){if(_.has(e))return console.log(`Ignoring duplicate share request for essay ${e}`),_.get(e)||Promise.resolve(!1);const r=await m(),o=`${w.ESSAY}:${e}`,a=(async()=>{u.update(t=>{const i=t.shares[o]||0;return{...t,shares:{...t.shares,[o]:i+1}}});try{const{data:t,error:i}=await n.from("essay_interactions").select("id, share_count").eq("device_id",r).eq("essay_id",e).single();if(i&&i.code!=="PGRST116")throw i;if(t){const c=(t.share_count||0)+1,{error:l}=await n.from("essay_interactions").update({share_count:c,updated_at:new Date().toISOString()}).eq("id",t.id);if(l)throw l}else{const{error:c}=await n.from("essay_interactions").insert({device_id:r,essay_id:e,has_liked:!1,share_count:1,has_viewed:!0});if(c)throw c}const{error:s}=await n.rpc("increment_essay_share_count",{essay_id:e,increment_by:1});if(s){console.warn("RPC failed, using fallback method for updating share count:",s);const{data:c,error:l}=await n.from("essays").select("share_count").eq("id",e).single();if(l)throw l;const h=(c.share_count||0)+1,{error:d}=await n.from("essays").update({share_count:h}).eq("id",e);if(d)throw d}return await v(r),!0}catch(t){throw console.error("Error recording share:",t),u.update(i=>{const s=i.shares[o]||0;return{...i,shares:{...i.shares,[o]:Math.max(0,s-1)}}}),t}finally{setTimeout(()=>{_.delete(e)},500)}})();return _.set(e,a),a}const p=new Map;async function L(e){if(p.has(e))return console.log(`Ignoring duplicate view request for essay ${e}`),p.get(e)||Promise.resolve(!1);const r=await m(),o=`${w.ESSAY}:${e}`,a=(async()=>{u.update(t=>({...t,views:{...t.views,[o]:!0}}));try{const{data:t,error:i}=await n.from("essay_interactions").select("id, has_viewed").eq("device_id",r).eq("essay_id",e).single();if(i&&i.code!=="PGRST116")throw i;if(t){const{error:s}=await n.from("essay_interactions").update({has_viewed:!0,updated_at:new Date().toISOString()}).eq("id",t.id);if(s)throw s}else{const{error:s}=await n.from("essay_interactions").insert({device_id:r,essay_id:e,has_liked:!1,share_count:0,has_viewed:!0});if(s)throw s}{const{error:s}=await n.rpc("increment_essay_view_count",{essay_id:e,increment_by:1});if(s){console.warn("RPC failed, using fallback method for updating view count:",s);const{data:c,error:l}=await n.from("essays").select("view_count").eq("id",e).single();if(l)throw l;const h=(c.view_count||0)+1,{error:d}=await n.from("essays").update({view_count:h}).eq("id",e);if(d)throw d}}return await v(r),!0}catch(t){return console.error("Error recording view:",t),!1}finally{setTimeout(()=>{p.delete(e)},1e3)}})();return p.set(e,a),a}async function Y(e){try{console.log(`Getting interaction counts for essay ID: ${e}`);const{data:r,error:o}=await n.from("essays").select("like_count, share_count, view_count").eq("id",e).single();if(o)throw o;return console.log(`Retrieved counts for essay ${e}:`,{likeCount:r.like_count||0,shareCount:r.share_count||0,viewCount:r.view_count||0}),{likeCount:r.like_count||0,shareCount:r.share_count||0,viewCount:r.view_count||0}}catch(r){return console.error("Error getting essay interaction counts:",r),{likeCount:0,shareCount:0,viewCount:0}}}export{w as C,M as a,L as b,Y as g,P as i,T as r,U as s,A as t};
