import{s}from"./supabase.8f09c013.js";import{w as v}from"./index.c544c403.js";import{R as m}from"./scheduler.375bac4c.js";var E=(l=>(l.PROJECT="project",l))(E||{});const p=v({likes:{},follows:{},userEmail:void 0,initialized:!1}),k=()=>new Promise(l=>{let e=localStorage.getItem("device_id");e||(e=crypto.randomUUID(),localStorage.setItem("device_id",e)),l(e)}),S=async()=>{try{const l=await k(),{data:e,error:f}=await s.from("project_interactions").select("project_id, has_liked, has_followed, email").eq("device_id",l);if(f){console.error("Error fetching interactions:",f);return}const c={},u={};let n;e.forEach(i=>{const o=`${E.PROJECT}:${i.project_id}`;c[o]=i.has_liked||!1,u[o]=i.has_followed||!1,i.email&&(n=i.email)}),p.update(i=>({...i,likes:c,follows:u,userEmail:n,initialized:!0})),console.log("Initialized interaction state:",{likes:c,follows:u,userEmail:n})}catch(l){console.error("Failed to initialize interactions:",l)}},_=(l,e)=>`${l}:${e}`,b=l=>(m(p).initialized||S(),p.subscribe(l)),$=async(l,e)=>{try{const f=_(l,e),c=await k(),n=m(p).likes[f]||!1;p.update(r=>{const t={...r.likes};return t[f]=!n,{...r,likes:t}}),console.log(`Toggling like for ${l}:${e} to ${!n}`);const{data:i,error:o}=await s.from("project_interactions").select("*").eq("device_id",c).eq("project_id",e).maybeSingle();if(o)throw console.error("Error fetching interaction:",o),o;if(console.log("Existing interaction:",i),i){const{error:r}=await s.from("project_interactions").update({has_liked:!n,updated_at:new Date().toISOString()}).eq("device_id",c).eq("project_id",e);if(r)throw console.error("Error updating interaction:",r),r;console.log("Interaction updated successfully")}else{const{error:r}=await s.from("project_interactions").insert({device_id:c,project_id:e,has_liked:!n,has_followed:!1});if(r)throw console.error("Error inserting interaction:",r),r;console.log("New interaction created successfully")}if(n){const{error:r}=await s.rpc("decrement_project_likes",{project_id:e}).single();if(r){console.log("RPC failed (expected), using fallback method:",r.message);const{data:t,error:d}=await s.from("projects").select("likes").eq("id",e).single();if(d)throw console.error("Error fetching project:",d),d;console.log("Current project data:",t);const a=(t==null?void 0:t.likes)||0,w=Math.max(0,a-1);console.log(`Updating likes from ${a} to ${w}`);const{error:g}=await s.from("projects").update({likes:w}).eq("id",e);if(g)throw console.error("Error updating project likes:",g),g;console.log("Project likes updated successfully")}}else{const{error:r}=await s.rpc("increment_project_likes",{project_id:e}).single();if(r){console.log("RPC failed (expected), using fallback method:",r.message);const{data:t,error:d}=await s.from("projects").select("likes").eq("id",e).single();if(d)throw console.error("Error fetching project:",d),d;console.log("Current project data:",t);const a=(t==null?void 0:t.likes)||0,w=a+1;console.log(`Updating likes from ${a} to ${w}`);const{error:g}=await s.from("projects").update({likes:w}).eq("id",e);if(g)throw console.error("Error updating project likes:",g),g;console.log("Project likes updated successfully")}}return!n}catch(f){console.error("Failed to toggle like:",f);const c=_(l,e),n=m(p).likes[c]||!1;return p.update(i=>{const o={...i.likes};return o[c]=n,{...i,likes:o}}),n}},F=async(l,e,f)=>{try{const c=await k(),u=_(l,e),n=m(p),i=n.follows[u]||!1;if(!i&&!f&&!n.userEmail)return{success:!1,needsEmail:!0,newState:!1};if(p.update(o=>{const r={...o.follows};r[u]=!i;const t=f||o.userEmail;return{...o,follows:r,userEmail:t}}),i){const{error:o}=await s.from("project_interactions").update({has_followed:!1,updated_at:new Date().toISOString()}).eq("device_id",c).eq("project_id",e);if(o)throw o;const{error:r}=await s.rpc("decrement_project_follows",{project_id:e}).single();if(r){console.warn("RPC failed, using fallback method:",r);const{data:t,error:d}=await s.from("projects").select("follows").eq("id",e).single();if(d)throw d;if(t&&t.follows>0){const a=t.follows-1,{error:w}=await s.from("projects").update({follows:a}).eq("id",e);if(w)throw w}}}else{const o=f||n.userEmail,{data:r,error:t}=await s.from("project_interactions").select("id").eq("device_id",c).eq("project_id",e).single();if(t&&t.code!=="PGRST116")throw t;if(r){const{error:a}=await s.from("project_interactions").update({has_followed:!0,email:o,updated_at:new Date().toISOString()}).eq("device_id",c).eq("project_id",e);if(a)throw a}else{const{error:a}=await s.from("project_interactions").insert({device_id:c,project_id:e,has_liked:!1,has_followed:!0,email:o});if(a)throw a}const{error:d}=await s.rpc("increment_project_follows",{project_id:e}).single();if(d){console.warn("RPC failed, using fallback method:",d);const{data:a,error:w}=await s.from("projects").select("follows").eq("id",e).single();if(w)throw w;const j=((a==null?void 0:a.follows)||0)+1,{error:h}=await s.from("projects").update({follows:j}).eq("id",e);if(h)throw h}if(o){const{error:a}=await s.from("project_interactions").update({email:o}).eq("device_id",c);a&&console.error("Error updating email for all device interactions:",a)}}return{success:!0,needsEmail:!1,newState:!i}}catch(c){console.error("Error toggling follow:",c);const u=_(l,e),i=m(p).follows[u]||!1;return p.update(o=>{const r={...o.follows};return r[u]=i,{...o,follows:r}}),{success:!1,needsEmail:!1,newState:i}}};export{E as C,F as a,b as s,$ as t};
