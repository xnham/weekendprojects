import{s as n}from"./supabase.8f09c013.js";import{w as H}from"./index.c4045f35.js";import{R as k}from"./scheduler.6e697b3e.js";var E=(e=>(e.PROJECT="project",e))(E||{});class _{constructor(t=0,r="Network Error"){this.status=t,this.text=r}}const x=()=>{if(!(typeof localStorage>"u"))return{get:e=>Promise.resolve(localStorage.getItem(e)),set:(e,t)=>Promise.resolve(localStorage.setItem(e,t)),remove:e=>Promise.resolve(localStorage.removeItem(e))}},p={origin:"https://api.emailjs.com",blockHeadless:!1,storageProvider:x()},j=e=>e?typeof e=="string"?{publicKey:e}:e.toString()==="[object Object]"?e:{}:{},U=(e,t="https://api.emailjs.com")=>{if(!e)return;const r=j(e);p.publicKey=r.publicKey,p.blockHeadless=r.blockHeadless,p.storageProvider=r.storageProvider,p.blockList=r.blockList,p.limitRate=r.limitRate,p.origin=r.origin||t},S=async(e,t,r={})=>{const o=await fetch(p.origin+e,{method:"POST",headers:r,body:t}),l=await o.text(),i=new _(o.status,l);if(o.ok)return i;throw i},P=(e,t,r)=>{if(!e||typeof e!="string")throw"The public key is required. Visit https://dashboard.emailjs.com/admin/account";if(!t||typeof t!="string")throw"The service ID is required. Visit https://dashboard.emailjs.com/admin";if(!r||typeof r!="string")throw"The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"},$=e=>{if(e&&e.toString()!=="[object Object]")throw"The template params have to be the object. Visit https://www.emailjs.com/docs/sdk/send/"},q=e=>e.webdriver||!e.languages||e.languages.length===0,L=()=>new _(451,"Unavailable For Headless Browser"),V=(e,t)=>{if(!Array.isArray(e))throw"The BlockList list has to be an array";if(typeof t!="string")throw"The BlockList watchVariable has to be a string"},K=e=>{var t;return!((t=e.list)!=null&&t.length)||!e.watchVariable},z=(e,t)=>e instanceof FormData?e.get(t):e[t],R=(e,t)=>{if(K(e))return!1;V(e.list,e.watchVariable);const r=z(t,e.watchVariable);return typeof r!="string"?!1:e.list.includes(r)},T=()=>new _(403,"Forbidden"),B=(e,t)=>{if(typeof e!="number"||e<0)throw"The LimitRate throttle has to be a positive number";if(t&&typeof t!="string")throw"The LimitRate ID has to be a non-empty string"},N=async(e,t,r)=>{const o=Number(await r.get(e)||0);return t-Date.now()+o},C=async(e,t,r)=>{if(!t.throttle||!r)return!1;B(t.throttle,t.id);const o=t.id||e;return await N(o,t.throttle,r)>0?!0:(await r.set(o,Date.now().toString()),!1)},F=()=>new _(429,"Too Many Requests"),M=async(e,t,r,o)=>{const l=j(o),i=l.publicKey||p.publicKey,a=l.blockHeadless||p.blockHeadless,m=l.storageProvider||p.storageProvider,d={...p.blockList,...l.blockList},s={...p.limitRate,...l.limitRate};return a&&q(navigator)?Promise.reject(L()):(P(i,e,t),$(r),r&&R(d,r)?Promise.reject(T()):await C(location.pathname,s,m)?Promise.reject(F()):S("/api/v1.0/email/send",JSON.stringify({lib_version:"4.4.1",user_id:i,service_id:e,template_id:t,template_params:r}),{"Content-type":"application/json"}))},J=e=>{if(!e||e.nodeName!=="FORM")throw"The 3rd parameter is expected to be the HTML form element or the style selector of the form"},A=e=>typeof e=="string"?document.querySelector(e):e,G=async(e,t,r,o)=>{const l=j(o),i=l.publicKey||p.publicKey,a=l.blockHeadless||p.blockHeadless,m=p.storageProvider||l.storageProvider,d={...p.blockList,...l.blockList},s={...p.limitRate,...l.limitRate};if(a&&q(navigator))return Promise.reject(L());const c=A(r);P(i,e,t),J(c);const f=new FormData(c);return R(d,f)?Promise.reject(T()):await C(location.pathname,s,m)?Promise.reject(F()):(f.append("lib_version","4.4.1"),f.append("service_id",e),f.append("template_id",t),f.append("user_id",i),S("/api/v1.0/email/send-form",f))},W={init:U,send:M,sendForm:G,EmailJSResponseStatus:_},g=H({likes:{},follows:{},userEmail:void 0,initialized:!1}),y=()=>new Promise(e=>{let t=localStorage.getItem("device_id");t||(t=crypto.randomUUID(),localStorage.setItem("device_id",t)),e(t)}),Z=async()=>{try{const e=await y(),{data:t,error:r}=await n.from("project_interactions").select("project_id, has_liked, has_followed, email").eq("device_id",e);if(r){console.error("Error fetching interactions:",r);return}const o={},l={};let i;t.forEach(a=>{const m=`${E.PROJECT}:${a.project_id}`;o[m]=a.has_liked||!1,l[m]=a.has_followed||!1,a.email&&(i=a.email)}),g.update(a=>({...a,likes:o,follows:l,userEmail:i,initialized:!0})),console.log("Initialized interaction state:",{likes:o,follows:l,userEmail:i})}catch(e){console.error("Failed to initialize interactions:",e)}},b=(e,t)=>`${e}:${t}`,I=e=>(k(g).initialized||Z(),g.subscribe(e));async function O(e){try{const t={to_email:"wendyham@gmail.com",interaction_type:e.type,project_id:e.projectId,project_title:e.projectTitle,timestamp:e.timestamp};await W.send("service_gdtxazl","template_lf4demg",t,"hjDvwfd_qUDUeDZOa")}catch(t){console.error("Failed to send interaction notification:",t)}}const ee=async(e,t)=>{try{const r=b(e,t),o=await y(),i=k(g).likes[r]||!1;g.update(s=>{const c={...s.likes};return c[r]=!i,{...s,likes:c}});const{data:a}=await n.from("projects").select("title").eq("id",t).single();await O({type:i?"unlike":"like",projectId:t,projectTitle:(a==null?void 0:a.title)||"Unknown Project",timestamp:new Date().toISOString()}),console.log(`Toggling like for ${e}:${t} to ${!i}`);const{data:m,error:d}=await n.from("project_interactions").select("*").eq("device_id",o).eq("project_id",t).maybeSingle();if(d)throw console.error("Error fetching interaction:",d),d;if(console.log("Existing interaction:",m),m){const{error:s}=await n.from("project_interactions").update({has_liked:!i,updated_at:new Date().toISOString()}).eq("device_id",o).eq("project_id",t);if(s)throw console.error("Error updating interaction:",s),s;console.log("Interaction updated successfully")}else{const{error:s}=await n.from("project_interactions").insert({device_id:o,project_id:t,has_liked:!i,has_followed:!1});if(s)throw console.error("Error inserting interaction:",s),s;console.log("New interaction created successfully")}if(i){const{error:s}=await n.rpc("decrement_project_likes",{project_id:t}).single();if(s){console.log("RPC failed (expected), using fallback method:",s.message);const{data:c,error:f}=await n.from("projects").select("likes").eq("id",t).single();if(f)throw console.error("Error fetching project:",f),f;console.log("Current project data:",c);const u=(c==null?void 0:c.likes)||0,w=Math.max(0,u-1);console.log(`Updating likes from ${u} to ${w}`);const{error:h}=await n.from("projects").update({likes:w}).eq("id",t);if(h)throw console.error("Error updating project likes:",h),h;console.log("Project likes updated successfully")}}else{const{error:s}=await n.rpc("increment_project_likes",{project_id:t}).single();if(s){console.log("RPC failed (expected), using fallback method:",s.message);const{data:c,error:f}=await n.from("projects").select("likes").eq("id",t).single();if(f)throw console.error("Error fetching project:",f),f;console.log("Current project data:",c);const u=(c==null?void 0:c.likes)||0,w=u+1;console.log(`Updating likes from ${u} to ${w}`);const{error:h}=await n.from("projects").update({likes:w}).eq("id",t);if(h)throw console.error("Error updating project likes:",h),h;console.log("Project likes updated successfully")}}return!i}catch(r){console.error("Failed to toggle like:",r);const o=b(e,t),i=k(g).likes[o]||!1;return g.update(a=>{const m={...a.likes};return m[o]=i,{...a,likes:m}}),i}},te=async(e,t,r)=>{try{const o=await y(),l=b(e,t),i=k(g),a=i.follows[l]||!1,{data:m}=await n.from("projects").select("title").eq("id",t).single();if(await O({type:a?"unfollow":"follow",projectId:t,projectTitle:(m==null?void 0:m.title)||"Unknown Project",timestamp:new Date().toISOString()}),!a&&!r&&!i.userEmail)return{success:!1,needsEmail:!0,newState:!1};if(g.update(d=>{const s={...d.follows};s[l]=!a;const c=r||d.userEmail;return{...d,follows:s,userEmail:c}}),a){const{error:d}=await n.from("project_interactions").update({has_followed:!1,updated_at:new Date().toISOString()}).eq("device_id",o).eq("project_id",t);if(d)throw d;const{error:s}=await n.rpc("decrement_project_follows",{project_id:t}).single();if(s){console.warn("RPC failed, using fallback method:",s);const{data:c,error:f}=await n.from("projects").select("follows").eq("id",t).single();if(f)throw f;if(c&&c.follows>0){const u=c.follows-1,{error:w}=await n.from("projects").update({follows:u}).eq("id",t);if(w)throw w}}}else{const d=r||i.userEmail,{data:s,error:c}=await n.from("project_interactions").select("id").eq("device_id",o).eq("project_id",t).single();if(c&&c.code!=="PGRST116")throw c;if(s){const{error:u}=await n.from("project_interactions").update({has_followed:!0,email:d,updated_at:new Date().toISOString()}).eq("device_id",o).eq("project_id",t);if(u)throw u}else{const{error:u}=await n.from("project_interactions").insert({device_id:o,project_id:t,has_liked:!1,has_followed:!0,email:d});if(u)throw u}const{error:f}=await n.rpc("increment_project_follows",{project_id:t}).single();if(f){console.warn("RPC failed, using fallback method:",f);const{data:u,error:w}=await n.from("projects").select("follows").eq("id",t).single();if(w)throw w;const D=((u==null?void 0:u.follows)||0)+1,{error:v}=await n.from("projects").update({follows:D}).eq("id",t);if(v)throw v}if(d){const{error:u}=await n.from("project_interactions").update({email:d}).eq("device_id",o);u&&console.error("Error updating email for all device interactions:",u)}}return{success:!0,needsEmail:!1,newState:!a}}catch(o){console.error("Error toggling follow:",o);const l=b(e,t),a=k(g).follows[l]||!1;return g.update(m=>{const d={...m.follows};return d[l]=a,{...m,follows:d}}),{success:!1,needsEmail:!1,newState:a}}};export{E as C,te as a,I as s,ee as t};
