import {
  icon,
  parse$1
} from "./chunk-GH2QFOMP.js";
import {
  add_locations,
  bind_this,
  check_target,
  hmr,
  html,
  if_block,
  init,
  legacy_api,
  legacy_rest_props,
  prop,
  set_attributes,
  spread_props
} from "./chunk-IF7INCMO.js";
import {
  append,
  comment,
  ns_template
} from "./chunk-37LVIGST.js";
import {
  FILENAME,
  HMR,
  add_owner_effect,
  child,
  first_child,
  get,
  mark_module_end,
  mark_module_start,
  mutable_state,
  pop,
  push,
  reset,
  set,
  strict_equals,
  template_effect
} from "./chunk-E7VVLN2B.js";
import "./chunk-X4XZK27Q.js";
import "./chunk-FF73JAKI.js";
import "./chunk-RIXFT5AQ.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-XSCQBFM2.js";

// node_modules/@fortawesome/svelte-fontawesome/src/utils/get-class-list-from-props.js
function classList(props) {
  const {
    beat,
    fade,
    beatFade,
    bounce,
    shake,
    flash,
    spin,
    spinPulse,
    spinReverse,
    pulse,
    fixedWidth,
    inverse,
    border,
    listItem,
    flip,
    size,
    rotation,
    pull
  } = props;
  const classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip === true,
    "fa-flip-horizontal": flip === "horizontal" || flip === "both",
    "fa-flip-vertical": flip === "vertical" || flip === "both",
    [`fa-${size}`]: typeof size !== "undefined" && size !== null,
    [`fa-rotate-${rotation}`]: typeof rotation !== "undefined" && rotation !== null && rotation !== 0,
    [`fa-pull-${pull}`]: typeof pull !== "undefined" && pull !== null,
    "fa-swap-opacity": props.swapOpacity
  };
  return Object.keys(classes).map((key) => classes[key] ? key : null).filter((key) => key);
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/camelize.js
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  }
  string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string.substr(0, 1).toLowerCase() + string.substr(1);
}

// node_modules/@fortawesome/svelte-fontawesome/src/converter.js
function styleToString(style) {
  if (typeof style === "string") {
    return style;
  }
  return Object.keys(style).reduce((acc, key) => acc + key.split(/(?=[A-Z])/).join("-").toLowerCase() + ":" + style[key] + ";", "");
}
function convert(createElement, element, extraProps = {}) {
  if (typeof element === "string") {
    return element;
  }
  const children = (element.children || []).map((child2) => {
    return convert(createElement, child2);
  });
  const mixins = Object.keys(element.attributes || {}).reduce(
    (acc, key) => {
      const val = element.attributes[key];
      if (key === "style") {
        acc.attrs["style"] = styleToString(val);
      } else {
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
      }
      return acc;
    },
    { attrs: {} }
  );
  return createElement(element.tag, { ...mixins.attrs }, children);
}
var converter_default = convert;

// node_modules/@fortawesome/svelte-fontawesome/src/logger.js
var PRODUCTION = false;
try {
  PRODUCTION = false;
} catch (e) {
}
function logger_default(...args) {
  if (!PRODUCTION && console && typeof console.error === "function") {
    console.error(...args);
  }
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/normalize-icon-args.js
function normalizeIconArgs(icon2) {
  if (icon2 && typeof icon2 === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return { prefix: icon2[0], iconName: icon2[1] };
  }
  if (typeof icon2 === "string") {
    return { prefix: "fas", iconName: icon2 };
  }
}

// node_modules/@fortawesome/svelte-fontawesome/src/utils/object-with-key.js
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? { [key]: value } : {};
}

// node_modules/@fortawesome/svelte-fontawesome/src/components/SvgElement.svelte
mark_module_start();
SvgElement[FILENAME] = "node_modules/@fortawesome/svelte-fontawesome/src/components/SvgElement.svelte";
var root = add_locations(ns_template(`<svg><!></svg>`), SvgElement[FILENAME], [[33, 0]]);
function SvgElement($$anchor, $$props) {
  var _a;
  check_target(new.target);
  push($$props, false, SvgElement);
  let tag = prop($$props, "tag", 8);
  let props = prop($$props, "props", 8);
  let children = prop($$props, "children", 8);
  let style = prop($$props, "style", 8, null);
  let ref = prop($$props, "ref", 12, null);
  if (strict_equals(tag(), "svg", false)) {
    throw new Error('SvgElement requires a tag of "svg"');
  }
  function processChildren(children2) {
    return (children2 == null ? void 0 : children2.reduce(
      (acc, child2) => {
        return acc + (child2.tag ? generateMarkup(child2) : child2);
      },
      ""
    )) || "";
  }
  function generateMarkup({ tag: tag2, props: props2, children: children2 }) {
    const attributes = Object.keys(props2).map((key) => `${key}="${props2[key]}"`).join(" ");
    return `<${tag2} ${attributes}>${processChildren(children2)}</${tag2}>`;
  }
  const markup = processChildren(children());
  const elementStyle = ((_a = props()) == null ? void 0 : _a.style) ? `${props().style}${style() || ""}` : style();
  const elementProps = { ...props(), style: elementStyle };
  init();
  var svg = root();
  let attributes_1;
  var node = child(svg);
  html(node, () => markup, true, false);
  reset(svg);
  bind_this(svg, ($$value) => ref($$value), () => ref());
  template_effect(() => attributes_1 = set_attributes(svg, attributes_1, { ...elementProps }));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SvgElement = hmr(SvgElement, () => SvgElement[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SvgElement[HMR].source;
    set(SvgElement[HMR].source, module.default[HMR].original);
  });
}
var SvgElement_default = SvgElement;
mark_module_end(SvgElement);

// node_modules/@fortawesome/svelte-fontawesome/src/components/FontAwesomeIcon.svelte
mark_module_start();
FontAwesomeIcon[FILENAME] = "node_modules/@fortawesome/svelte-fontawesome/src/components/FontAwesomeIcon.svelte";
function FontAwesomeIcon($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "border",
    "mask",
    "maskId",
    "fixedWidth",
    "inverse",
    "flip",
    "icon",
    "listItem",
    "pull",
    "pulse",
    "rotation",
    "size",
    "spin",
    "spinPulse",
    "spinReverse",
    "beat",
    "fade",
    "beatFade",
    "bounce",
    "shake",
    "symbol",
    "title",
    "titleId",
    "transform",
    "swapOpacity",
    "ref",
    "style"
  ]);
  push($$props, false, FontAwesomeIcon);
  let border = prop($$props, "border", 8, false);
  let mask = prop($$props, "mask", 8, null);
  let maskId = prop($$props, "maskId", 8, null);
  let fixedWidth = prop($$props, "fixedWidth", 8, false);
  let inverse = prop($$props, "inverse", 8, false);
  let flip = prop($$props, "flip", 8, false);
  let icon2 = prop($$props, "icon", 8, null);
  let listItem = prop($$props, "listItem", 8, false);
  let pull = prop($$props, "pull", 8, null);
  let pulse = prop($$props, "pulse", 8, false);
  let rotation = prop($$props, "rotation", 8, null);
  let size = prop($$props, "size", 8, null);
  let spin = prop($$props, "spin", 8, false);
  let spinPulse = prop($$props, "spinPulse", 8, false);
  let spinReverse = prop($$props, "spinReverse", 8, false);
  let beat = prop($$props, "beat", 8, false);
  let fade = prop($$props, "fade", 8, false);
  let beatFade = prop($$props, "beatFade", 8, false);
  let bounce = prop($$props, "bounce", 8, false);
  let shake = prop($$props, "shake", 8, false);
  let symbol = prop($$props, "symbol", 8, false);
  let title = prop($$props, "title", 8, "");
  let titleId = prop($$props, "titleId", 8, null);
  let transform = prop($$props, "transform", 8, null);
  let swapOpacity = prop($$props, "swapOpacity", 8, false);
  let ref = prop($$props, "ref", 12, null);
  let style = prop($$props, "style", 8, null);
  const iconLookup = normalizeIconArgs(icon2());
  const classes = objectWithKey("classes", [
    ...classList($$sanitized_props),
    ...($$sanitized_props.class || "").split(" ")
  ]);
  const transformObj = objectWithKey("transform", strict_equals(typeof transform(), "string") ? parse$1.transform(transform()) : transform());
  const maskObj = objectWithKey("mask", normalizeIconArgs(mask()));
  const renderedIcon = icon(iconLookup, {
    ...classes,
    ...transformObj,
    ...maskObj,
    symbol: symbol(),
    title: title(),
    titleId: titleId(),
    maskId: maskId()
  });
  let result = mutable_state(null);
  if (!renderedIcon) {
    logger_default("Could not find icon", iconLookup);
  } else {
    const { abstract } = renderedIcon;
    set(result, converter_default(
      (tag, props, children) => {
        return { tag, props, children };
      },
      abstract[0],
      $$restProps
    ));
  }
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, SvgElement_default);
        SvgElement_default(node_1, spread_props(() => get(result), {
          get style() {
            return style();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          $$legacy: true
        }));
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (get(result)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FontAwesomeIcon = hmr(FontAwesomeIcon, () => FontAwesomeIcon[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontAwesomeIcon[HMR].source;
    set(FontAwesomeIcon[HMR].source, module.default[HMR].original);
  });
}
var FontAwesomeIcon_default = FontAwesomeIcon;
mark_module_end(FontAwesomeIcon);
export {
  FontAwesomeIcon_default as FontAwesomeIcon
};
//# sourceMappingURL=@fortawesome_svelte-fontawesome.js.map
